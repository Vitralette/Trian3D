%% Visualize Complete Scenario
% This script displays the final scenario with terrain contours and all
% KML objects overlaid. Select which layers to display.
%
% Author: Tim Jusko
% Date: 2026-02-07

clear; clc; close all;

%% Load Project Configuration
config = load_project_config();
editedFolder = config.editedFolder;
exportFolder = config.exportFolder;

fprintf('Project: %s\n', config.projectName);

%% Layer Selection - Toggle which elements to display
showTerrain = true;           % Contour plot of edited terrain
showTrack = true;             % Track centerline and corridor
showTrees = false;             % Point trees from KML
showPowerlines = true;        % Powerline obstacles from KML
showForest = true;            % Forest polygon from KML

% Display settings
terrainContourLevels = 20;    % Number of contour levels
forestAlpha = 0.3;            % Forest polygon transparency

%% Load track geometry
geometryFile = fullfile(editedFolder, 'track_geometry.mat');
if ~exist(geometryFile, 'file')
    error('Track geometry file not found. Run generate_groundtrack.m first.');
end
fprintf('Loading track geometry...\n');
geomData = load(geometryFile);
geom = geomData.trackGeometry;

waypoints = geom.waypoints;
corridorWidth = geom.corridorWidth;
halfWidth = corridorWidth / 2;
xMinTotal = geom.xMinTerrain;
xMaxTotal = geom.xMaxTerrain;
yMinTotal = geom.yMinTerrain;
yMaxTotal = geom.yMaxTerrain;

fprintf('  Track Seed: %d\n', geom.randomSeed);
fprintf('  Total length: %.0f m\n', geom.totalLength);

%% Load terrain data
if showTerrain
    fprintf('Loading terrain data...\n');
    
    tifBaseNames = {
        'dgm1_32_495_5802_1_nw_2023'
        'dgm1_32_496_5802_1_nw_2023'
    };
    numTiles = length(tifBaseNames);
    geoInfo = cell(numTiles, 1);
    elevationData = cell(numTiles, 1);
    
    for i = 1:numTiles
        baseName = tifBaseNames{i};
        
        geoInfoFile = fullfile(editedFolder, [baseName '_geotiffinfo_edited.mat']);
        geoInfoData = load(geoInfoFile);
        geoInfoFields = fieldnames(geoInfoData);
        geoInfo{i} = geoInfoData.(geoInfoFields{1});
        
        rasterFile = fullfile(editedFolder, [baseName '_readgeoraster_edited.mat']);
        rasterData = load(rasterFile);
        elevationData{i} = rasterData.A;
    end
    
    % Merge tiles
    cellSize = geoInfo{1}.PixelScale(1);
    nColsTotal = round((xMaxTotal - xMinTotal) / cellSize);
    nRowsTotal = round((yMaxTotal - yMinTotal) / cellSize);
    mergedElevation = NaN(nRowsTotal, nColsTotal);
    
    for i = 1:numTiles
        bbox = geoInfo{i}.BoundingBox;
        tileXMin = bbox(1,1);
        tileYMax = bbox(2,2);
        
        colStart = round((tileXMin - xMinTotal) / cellSize) + 1;
        rowStart = round((yMaxTotal - tileYMax) / cellSize) + 1;
        
        [tileRows, tileCols] = size(elevationData{i});
        rowEnd = min(rowStart + tileRows - 1, nRowsTotal);
        colEnd = min(colStart + tileCols - 1, nColsTotal);
        
        mergedElevation(rowStart:rowEnd, colStart:colEnd) = ...
            elevationData{i}(1:(rowEnd-rowStart+1), 1:(colEnd-colStart+1));
    end
    
    fprintf('  Terrain loaded: %d x %d pixels\n', nRowsTotal, nColsTotal);
end

%% Load object data from .mat files (generated by KML scripts)
% These .mat files contain data RECONSTRUCTED FROM KML - exactly what Trian3D will see

% Trees data (reconstructed from KML)
treesMatFile = fullfile(editedFolder, 'point_trees_data.mat');
if showTrees && exist(treesMatFile, 'file')
    fprintf('Loading trees data (from KML)...\n');
    treeDataLoaded = load(treesMatFile);
    treeData = treeDataLoaded.treeData;
    
    % Data is already combined (reconstructed from KML)
    treeEastings = treeData.treeEastings;
    treeNorthings = treeData.treeNorthings;
    numTrees = treeData.numTrees;
    fprintf('  Loaded %d trees\n', numTrees);
else
    showTrees = false;
    numTrees = 0;
    fprintf('  Trees data not found, skipping\n');
end

% Powerlines data (reconstructed from KML)
powerlineMatFile = fullfile(editedFolder, 'linestring_powerline_data.mat');
if showPowerlines && exist(powerlineMatFile, 'file')
    fprintf('Loading powerlines data (from KML)...\n');
    powerlineDataLoaded = load(powerlineMatFile);
    pData = powerlineDataLoaded.powerlineData;
    
    numPowerlines = pData.numPowerlines;
    powerlines = pData.powerlines;  % Struct array with .leftX/Y, .rightX/Y (from KML)
    fprintf('  Loaded %d powerlines (seed: %d)\n', numPowerlines, pData.powerlineSeed);
else
    showPowerlines = false;
    numPowerlines = 0;
    fprintf('  Powerlines data not found, skipping\n');
end

% Forest data (reconstructed from KML)
forestMatFile = fullfile(editedFolder, 'polygon_forest_data.mat');
if showForest && exist(forestMatFile, 'file')
    fprintf('Loading forest data (from KML)...\n');
    forestDataLoaded = load(forestMatFile);
    fData = forestDataLoaded.forestData;
    
    numForestPolys = fData.numPolygons;
    forestPolys = fData.polygons;  % Cell array, each with .x, .y (UTM from KML)
    fprintf('  Loaded %d forest polygons\n', numForestPolys);
else
    showForest = false;
    numForestPolys = 0;
    fprintf('  Forest data not found, skipping\n');
end

%% Create visualization
fprintf('\nGenerating visualization...\n');

figure('Name', sprintf('Scenario Overview (Seed: %d)', geom.randomSeed), ...
    'Position', [100 100 1200 800]);

% Terrain contour plot
if showTerrain
    [X, Y] = meshgrid(linspace(xMinTotal, xMaxTotal, nColsTotal), ...
                       linspace(yMaxTotal, yMinTotal, nRowsTotal));
    contourf(X, Y, mergedElevation, terrainContourLevels);
    colormap(parula);
    cb = colorbar; 
    cb.Label.String = 'Elevation (m)';
end

hold on;

% Forest polygons (draw first so they're behind other elements)
% Data is already reconstructed from KML - plot directly
if showForest
    forestColor = [0.2 0.6 0.2];
    for p = 1:numForestPolys
        if p == 1
            patch(forestPolys{p}.x, forestPolys{p}.y, forestColor, ...
                'FaceAlpha', forestAlpha, 'EdgeColor', [0 0.4 0], 'LineWidth', 0.5, ...
                'DisplayName', sprintf('Forest (%d polys)', numForestPolys));
        else
            patch(forestPolys{p}.x, forestPolys{p}.y, forestColor, ...
                'FaceAlpha', forestAlpha, 'EdgeColor', [0 0.4 0], 'LineWidth', 0.5, ...
                'HandleVisibility', 'off');
        end
    end
end

% Trees
if showTrees
    plot(treeEastings, treeNorthings, '^', 'MarkerSize', 4, ...
        'MarkerFaceColor', [0.1 0.5 0.1], 'MarkerEdgeColor', [0 0.3 0], ...
        'DisplayName', sprintf('Trees (%d)', numTrees));
end

% Track and corridor
if showTrack
    % Corridor boundaries
    numWaypoints = length(waypoints);
    leftBoundX = zeros(numWaypoints, 1);
    leftBoundY = zeros(numWaypoints, 1);
    rightBoundX = zeros(numWaypoints, 1);
    rightBoundY = zeros(numWaypoints, 1);
    
    for i = 1:numWaypoints
        if i < numWaypoints
            dx = waypoints(i+1).x - waypoints(i).x;
            dy = waypoints(i+1).y - waypoints(i).y;
        else
            dx = waypoints(i).x - waypoints(i-1).x;
            dy = waypoints(i).y - waypoints(i-1).y;
        end
        len = sqrt(dx^2 + dy^2);
        if len > 0.1
            perpX = -dy / len;
            perpY = dx / len;
        else
            perpX = 0;
            perpY = 1;
        end
        
        leftBoundX(i) = waypoints(i).x + halfWidth * perpX;
        leftBoundY(i) = waypoints(i).y + halfWidth * perpY;
        rightBoundX(i) = waypoints(i).x - halfWidth * perpX;
        rightBoundY(i) = waypoints(i).y - halfWidth * perpY;
    end
    
    plot(leftBoundX, leftBoundY, 'r--', 'LineWidth', 1, 'HandleVisibility', 'off');
    plot(rightBoundX, rightBoundY, 'r--', 'LineWidth', 1, 'HandleVisibility', 'off');
    
    % Track centerline
    trackX = [waypoints.x];
    trackY = [waypoints.y];
    plot(trackX, trackY, 'r-', 'LineWidth', 2.5, 'DisplayName', 'Track');
    
    % Start/end markers
    plot(waypoints(1).x, waypoints(1).y, 'o', 'MarkerSize', 12, ...
        'MarkerFaceColor', [0 0.8 0], 'MarkerEdgeColor', 'k', 'LineWidth', 2, ...
        'DisplayName', 'Start');
    plot(waypoints(end).x, waypoints(end).y, 's', 'MarkerSize', 12, ...
        'MarkerFaceColor', [0.8 0 0], 'MarkerEdgeColor', 'k', 'LineWidth', 2, ...
        'DisplayName', 'End');
end

% Powerlines (draw last so they're on top)
if showPowerlines
    powerlineColor = [1 0.5 0];  % Orange
    for p = 1:numPowerlines
        % Each powerline has leftX/Y and rightX/Y endpoints
        plX = [powerlines(p).leftX, powerlines(p).rightX];
        plY = [powerlines(p).leftY, powerlines(p).rightY];
        
        if p == 1
            plot(plX, plY, '-', 'Color', powerlineColor, ...
                'LineWidth', 3, 'DisplayName', sprintf('Powerlines (%d)', numPowerlines));
        else
            plot(plX, plY, '-', 'Color', powerlineColor, ...
                'LineWidth', 3, 'HandleVisibility', 'off');
        end
        % Mark endpoints
        plot(plX, plY, 'o', 'Color', powerlineColor, ...
            'MarkerSize', 6, 'MarkerFaceColor', powerlineColor, 'HandleVisibility', 'off');
    end
end

% Formatting
xlabel('Easting (m)');
ylabel('Northing (m)');
title(sprintf('Scenario Overview\nTrack Seed: %d | Length: %.0f m | Corridor: %.0f m', ...
    geom.randomSeed, geom.totalLength, corridorWidth));
axis equal tight;
legend('Location', 'best');
grid on;

hold off;

%% Summary
fprintf('\n=== Visualization Complete ===\n');
fprintf('Layers displayed:\n');
fprintf('  Terrain:    %s\n', mat2str(showTerrain));
fprintf('  Track:      %s\n', mat2str(showTrack));
fprintf('  Trees:      %s', mat2str(showTrees));
if showTrees, fprintf(' (%d)', numTrees); end
fprintf('\n');
fprintf('  Powerlines: %s', mat2str(showPowerlines));
if showPowerlines, fprintf(' (%d)', numPowerlines); end
fprintf('\n');
fprintf('  Forest:     %s', mat2str(showForest));
if showForest, fprintf(' (%d polygons)', numForestPolys); end
fprintf('\n');

